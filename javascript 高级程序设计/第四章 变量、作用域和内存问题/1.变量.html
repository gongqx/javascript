<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        //javascript变量松散类型的本质，决定了它只是在特定时间用于保存特定值的一个名字而已。
        //ECMAScript变量可能包含两种不同数据类型的值：基本类型值和引用类型值。
        //基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。
        //基本类型值：Undefined、Null、Boolean、Number和String。这5种基本类型是按值访问的，
        //因为可以操作保存在变量中的实际的值。
        //引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，
        //也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。
        //为此，引用类型的值是按引用访问的。
        //只能给引用类型的值添加属性和方法。
        var person = new Object();
        person.name = 'xiaoxiao';
        console.log(person.name);
        //从一个变量向另一个变量复制基本类型的值，会在变量对象上创建一个新值，然后把该值复制到为新变量分配的位置上。
        var num1 = 5;
        var num2 = num1;
        //num2中的5与num1中的5完全独立。这两个变量可以参与任何操作而不受影响。
        //当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。
        //不同的是，这个值的副本实际上是一个指针。而这个指针指向存储在堆中的一个对象。
        //复制操作结束后，两个变量实际上将引用同一个对象。因此改变其中一个变量就会影响到另一个变量。
        var obj1 = new Object();
        var obj2 = obj1;
        obj1.name = 'lili';
        console.log(obj2.name);
        //ECMAScript中所有函数的参数都是按值传递的。
        function setName(obj) {
            obj.name = "Nicholas";
        }
        var person = new Object();
        setName(person);
        console.log(person.name);
        //如果person是按引用传递的，那么person就会自动被修改为指向其name属性值为“Greg”的新对象。
        function setName2(obj) {
            obj.name = "Nicholas";
            obj = new Object();
            obj.name = "Greg";
        }
        var person = new Object();
        setName(person);
        console.log(person.name);
        //typeof在检测基本数据类型时typeof是非常得力的助手。
        var s = "Nicholas";
        var b = true;
        var i = 22;
        var u;
        var n = null;
        var o = new Object();
        console.log(typeof s);
        console.log(typeof b);
        console.log(typeof i);
        console.log(typeof u);
        console.log(typeof n);
        console.log(typeof o);
        //但是在检测引用类型的值时，这个操作符的用处就不大了，因为我们确切的想知道它是什么类型的对象。
        //instanceof操作符就派上用场了。
        //如果变量是给定引用类型的实例，那么instanceof操作符就会返回true。
        var person = new Object();
        var colors = ["red","yellow","bule"];
        var pattern = /at/g;
        console.log(person instanceof Object);
        console.log(colors instanceof Array);
        console.log(pattern instanceof RegExp);
        //根据规定所有类型的值都是Object的实例。
        console.log(colors instanceof Object);//true
        console.log(person instanceof Array);//false
    </script>
</body>

</html>